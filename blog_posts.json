{
  "posts": [
    {
      "post_date": "2023-10-03T14:00:00",
      "title": "Automating Daily Blog Posts with GitHub Actions and Blogger API",
      "content": "<p>In this blog post, we'll explore a GitHub Actions workflow that automates the creation of daily blog posts using the Blogger API. This workflow allows you to schedule and publish blog posts at a specified time every day.</p><h2>GitHub Actions Workflow</h2><p>Let's dive into the GitHub Actions workflow defined in the <code>.github/workflows/daily-automation.yml</code> file.</p><pre><code>name: Daily Automated Actions\non:\n  schedule:\n    - cron: '0 14 * * *'\n  push:\n    branches:\n      - main\njobs:\n  daily-run:\n    name: 'Runs daily'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n        with:\n          fetch-depth: 2\n      - run: git checkout HEAD^2\n        if: ${{ github.event_name == 'pull_request' }}\n      - name: Setup Python version 3.9\n        uses: actions/setup-python@v2\n        with:\n          python-version: 3.9\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r requirements.txt\n      - name: Automate blog posts\n        run: |\n          python run.py --credentials '${{ secrets.credentials }}' --json '${{ secrets.json }}' --repo '${{ secrets.repo }}'\n</code></pre><h3>Workflow Steps:</h3><ol><li><strong>Checkout Repository:</strong> The action checks out the repository code.</li><li><strong>Python Setup:</strong> It sets up the Python environment with version 3.9.</li><li><strong>Install Dependencies:</strong> Installs the required dependencies defined in <code>requirements.txt</code>.</li><li><strong>Automate Blog Posts:</strong> Runs the <code>run.py</code> script to automate the creation of blog posts using the specified credentials, JSON file, and GitHub repository.</li></ol><h2>Python Script (<code>run.py</code>)</h2><p>Now, let's explore the Python script responsible for interacting with the Blogger API and creating blog posts.</p><pre><code># The content of run.py\n# ...\n# Example usage\nif __name__ == '__main__':\n    args = parse_args()\n    # Use the contents of the credentials file as a string\n    credentials_str = args.credentials\n    # Initialize the Blogger API client\n    blogger_service = get_blogger_service(credentials_str)\n    # Get the Blog ID\n    blog_id = get_blog_id(blogger_service)\n    if blog_id is None:\n        print('Unable to retrieve Blog ID. Exiting.')\n        exit(1)\n    # Read blog post information from JSON file on GitHub\n    github_repo = args.github_repo\n    json_file_path = args.json_file\n    blog_posts = read_json_file_from_github(github_repo, json_file_path)\n    if blog_posts is not None and 'posts' in blog_posts:\n        for post in blog_posts['posts']:\n            # ...\n            # Process and create blog posts based on the script logic\n            # ...\n</code></pre><h3>Key Script Components:</h3><ul><li><strong>Parsing Arguments:</strong> The script parses command-line arguments, including credentials, GitHub repository URL, and JSON file path.</li><li><strong>Blogger API Initialization:</strong> It initializes the Blogger API client using the provided credentials.</li><li><strong>Reading Blog Post Information:</strong> The script reads blog post information from a JSON file in the specified GitHub repository.</li><li><strong>Automating Post Creation:</strong> Based on the scheduled date and time, the script automates the creation of blog posts using the Blogger API.</li></ul><h2>Conclusion</h2><p>With this GitHub Actions workflow and Python script, you can effortlessly schedule and automate your daily blog posts, streamlining your content creation process. Customize the workflow and script to fit your specific requirements and enjoy a more efficient and consistent blogging experience.</p>"
    },
    {
      "post_date": "2023-10-04T14:00:00",
      "title": "The Polyglot Coder's Odyssey: A Strategic Guide to Mastering Python, C, Assembly, and Swift",
      "content": "<p>Embarking on the journey to master multiple programming languages is a thrilling endeavor that opens doors to diverse realms of software development. In this blog, we'll outline a comprehensive plan to conquer the coding landscapes of Python, C, Assembly, and Swift.</p><h2>1. Python - The Versatile Prelude:</h2><p>Start with Python, renowned for its simplicity and readability. Begin by mastering fundamental concepts like variables, data structures, and control flow. Interactive platforms like Codecademy and real-world application on platforms like LeetCode can provide hands-on experience.</p><h2>2. C - Navigating the Core:</h2><p>Transition to C, delving into the fundamentals of low-level programming. Focus on memory management, pointers, and understanding the inner workings of a computer. Books like \"C Programming Absolute Beginner's Guide\" and online platforms like HackerRank can deepen your C expertise.</p><h2>3. Assembly - Unveiling the Machine Code:</h2><p>Explore the intricate world of Assembly language to understand the architecture-level concepts. Experiment with emulators and platforms like Assembler School to visualize and practice low-level programming. Resources like \"Programming from the Ground Up\" by Bartlett can guide you through Assembly fundamentals.</p><h2>4. Swift - Apple's Modern Symphony:</h2><p>Dive into Swift, Apple's powerful and intuitive language. Start with Swift Playgrounds and Swift.org documentation to grasp the syntax and principles. Progress to iOS development, exploring frameworks like UIKit and SwiftUI. Building progressively complex apps will solidify your Swift skills.</p><h2>Structured Learning Path:</h2><ul><li><strong>Foundations:</strong> Master the basics of each language through online courses, tutorials, and coding exercises. Platforms like Udacity, Coursera, and freeCodeCamp offer structured learning paths.</li><li><strong>Projects and Applications:</strong> Reinforce your knowledge by working on practical projects. Build a web application with Python, create system-level programs with C, develop Assembly-based simulations, and craft interactive iOS apps with Swift.</li><li><strong>Community Engagement:</strong> Join programming communities such as Stack Overflow, Reddit, and language-specific forums. Engage in discussions, seek advice, and contribute to open-source projects. Learning from the community is a powerful accelerator.</li><li><strong>Continuous Practice:</strong> Dedicate regular time to coding challenges, algorithmic problem-solving, and personal projects. Consistent practice is the key to retaining and deepening your understanding of each language.</li></ul><p><strong>Conclusion:</strong> Mastering Python, C, Assembly, and Swift is an enriching journey that equips you with a versatile skill set. Follow this strategic guide, embrace challenges, and remember that the true mastery lies in applying your knowledge to real-world scenarios. Happy coding on your polyglot odyssey!</p>"
    },
    {
      "post_date": "2023-10-09T14:00:00",
      "title": "Mastering Zsh History Key Bindings: A Comprehensive Guide",
      "content": "<p>Zsh, or Z Shell, is a powerful command-line interpreter that brings efficiency and customization to your terminal experience. One of its standout features is the robust history system, coupled with versatile key bindings that allow users to navigate and manipulate command history effortlessly. In this guide, we'll explore the various Zsh history key bindings and how to leverage them effectively.</p><h2>Understanding Zsh History</h2><p>Zsh maintains a history of commands entered in a session, allowing users to recall, modify, and reuse commands easily. The history system is a valuable asset for command-line aficionados who want to streamline their workflows.</p><h3>1. Navigating History</h3><ul><li><strong>Ctrl + R:</strong> Initiate a reverse search through history. As you start typing, Zsh will match and display commands that contain the entered sequence.</li><li><strong>Ctrl + S:</strong> Perform a forward search through history.</li></ul><h3>2. Event Designators</h3><ul><li><strong>!!:</strong> Repeat the last command.</li><li><strong>!n:</strong> Repeat the nth command in the history.</li><li><strong>!-n:</strong> Repeat the command n entries back from the current command.</li></ul><h3>3. Word Designators</h3><ul><li><strong>!$:</strong> Refer to the last word of the previous command.</li><li><strong>!:1,3:</strong> Select words 1 to 3 from the previous command.</li></ul><h3>4. Modifying History Entries</h3><ul><li><strong>!!:s/old/new:</strong> Replace the first occurrence of 'old' with 'new' in the last command.</li><li><strong>!!:gs/old/new:</strong> Replace all occurrences of 'old' with 'new' in the last command.</li></ul><h3>5. Searching History</h3><ul><li><strong>Ctrl + R:</strong> Initiate an interactive history search.</li><li><strong>Ctrl + S:</strong> Perform a forward search through history.</li></ul><h3>6. Extracting Arguments from History</h3><ul><li><strong>!:1-3:</strong> Retrieve arguments 1 to 3 from the previous command.</li><li><strong>!$:h:</strong> Refer to the directory part of the last command.</li></ul><h3>7. Miscellaneous Key Bindings</h3><ul><li><strong>Alt + . (period):</strong> Insert the last argument from the previous command.</li></ul><h2>Customizing Zsh History Key Bindings</h2><p>Zsh allows users to customize key bindings to suit their preferences. The key bindings are configured in the <code>~/.zshrc</code> file. For example, to bind a custom function to a key combination:</p><pre><code>bindkey '^X^A' my_custom_function</code></pre><p>This binds <code>my_custom_function</code> to Ctrl + X followed by Ctrl + A.</p><h2>Conclusion</h2><p>Mastering Zsh history key bindings enhances your command-line proficiency and productivity. By understanding and customizing these bindings, you can navigate through command history, extract and modify commands efficiently, and tailor your Zsh experience to match your workflow preferences. Experiment with these key bindings to unlock the full potential of Zsh as your command-line companion.</p>"
    }
  ]
}
